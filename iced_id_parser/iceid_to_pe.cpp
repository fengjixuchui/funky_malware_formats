#include "iceid_to_pe.h"
#include "util.h"

#include <set>

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

BYTE* icedid::alloc_pe(IN const iced_module_hdr &hdr, OUT size_t &out_size)
{
	out_size = 0;
	BYTE* allocated = (BYTE*)VirtualAlloc(0, hdr.image_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (allocated) {
		out_size = hdr.image_size;
	}
	return allocated;
}

size_t icedid::copy_sections(IN const iced_module_hdr &hdr, IN OUT BYTE* buf, IN const size_t buf_size)
{
	size_t copied_cntr = 0;
	for (size_t i = 0; i < hdr.sections_count; i++) {
		if (hdr.sections[i].virtual_size == 0) continue;

		const size_t copy_size = hdr.sections[i].raw_size;

		BYTE* vptr = buf + hdr.sections[i].virtual_offset;
		if (!validate_ptr(buf, buf_size, vptr, copy_size)) continue;

		BYTE* rptr = (BYTE*)&hdr + hdr.sections[i].raw_offset;
		if (!validate_ptr((BYTE*)&hdr, hdr.image_size, rptr, copy_size)) continue;

		memcpy(vptr, rptr, copy_size);
		copied_cntr++;
	}
	return copied_cntr;
}

void sort_sections(IN const iced_module_hdr &hdr, std::map<DWORD, size_t> &sections_sorted)
{
	for (size_t i = 0; i < hdr.sections_count; i++) {
		DWORD offset = hdr.sections[i].virtual_offset;
		sections_sorted[offset] = i;
	}

	std::map<DWORD, size_t>::iterator itr;
	for (itr = sections_sorted.begin(); itr != sections_sorted.end(); itr++) {
		size_t index = itr->second;
		const ICED_SECTION& iceid_sec = hdr.sections[index];
	}
}

DWORD translate_protect(DWORD charact)
{
	switch (charact) {
	case PAGE_EXECUTE_READWRITE:
		return IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
	case PAGE_EXECUTE_READ:
		return IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;
	case PAGE_READWRITE:
		return IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ;
	case PAGE_READONLY:
		return IMAGE_SCN_MEM_READ;
	}
	return 0;
}

bool copy_sec_hdrs(IN const iced_module_hdr &hdr, IN OUT BYTE* buf, IN const size_t buf_size, size_t sec_hdr_offset)
{
	std::map<DWORD, size_t> sections_sorted;
	sort_sections(hdr, sections_sorted);

	BYTE* buffer = buf + sec_hdr_offset;
	std::map<DWORD, size_t>::iterator itr;
	size_t i = 0;
	for (itr = sections_sorted.begin(); itr != sections_sorted.end(); itr++, i++) {
		IMAGE_SECTION_HEADER* sections = (IMAGE_SECTION_HEADER*)((ULONG_PTR)buffer + sizeof(IMAGE_SECTION_HEADER) * i);
		if (!validate_ptr(buf, buf_size, sections, sizeof(IMAGE_SECTION_HEADER)) ) break;

		size_t index = itr->second;
		const ICED_SECTION& iceid_sec = hdr.sections[index];

		sections->VirtualAddress = iceid_sec.virtual_offset;
		sections->PointerToRawData = iceid_sec.virtual_offset;
		sections->SizeOfRawData = iceid_sec.raw_size;
		sections->Misc.VirtualSize = iceid_sec.virtual_size;
		sections->Characteristics = translate_protect(iceid_sec.characteristics);
	}

	std::cout << "[*] Copied section headers\n";
	return true;
}

template <typename IMAGE_NT_HEADERS_T>
void copy_headers(IN const iced_module_hdr &hdr, IN OUT BYTE* buf, IN const size_t buf_size, WORD machine)
{

	IMAGE_DOS_HEADER dos_hdr = { 0 };
	dos_hdr.e_magic = IMAGE_DOS_SIGNATURE;
	dos_hdr.e_lfanew = sizeof(IMAGE_DOS_HEADER);
	memcpy(buf, &dos_hdr, sizeof(IMAGE_DOS_HEADER));

	BYTE *vptr = buf + sizeof(IMAGE_DOS_HEADER);

	IMAGE_NT_HEADERS_T nt_hdr = { 0 };
	nt_hdr.Signature = IMAGE_NT_SIGNATURE;
	nt_hdr.FileHeader.NumberOfSections = hdr.sections_count;
	nt_hdr.FileHeader.SizeOfOptionalHeader = sizeof(nt_hdr.OptionalHeader);
	nt_hdr.FileHeader.Machine = machine;

	if (machine == IMAGE_FILE_MACHINE_I386) {
		nt_hdr.OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
	}
	else {
		nt_hdr.OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
	}
	nt_hdr.OptionalHeader.AddressOfEntryPoint = hdr.entry_point_va;
	nt_hdr.OptionalHeader.SizeOfImage = hdr.image_size;
	nt_hdr.OptionalHeader.FileAlignment = PAGE_SIZE;
	nt_hdr.OptionalHeader.SectionAlignment = PAGE_SIZE;
	nt_hdr.OptionalHeader.ImageBase = hdr.image_base;
	nt_hdr.OptionalHeader.SizeOfHeaders = sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS_T);
	nt_hdr.OptionalHeader.Subsystem = IMAGE_SUBSYSTEM_WINDOWS_GUI;

	nt_hdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = hdr.import_dir_va;
	nt_hdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = hdr.reloc_dir_va;
	nt_hdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = hdr.reloc_dir_size;

	memcpy(vptr, &nt_hdr, sizeof(IMAGE_NT_HEADERS_T));

	size_t sec_hdr_offset = sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS_T);
	copy_sec_hdrs(hdr, buf, buf_size, sec_hdr_offset);
}


bool icedid::convert_to_pe(const iced_module_hdr& hdr, char* filename)
{
	size_t buf_size = 0;
	BYTE* buf = alloc_pe(hdr, buf_size);
	if (!buf) return false;

	copy_sections(hdr, buf, buf_size);
	bool is32bit = true;

	if ((DWORD(hdr.image_base)) < hdr.image_base) {
		is32bit = false;
	}
	if (is32bit) {
		std::cout << "[*] 32bit module\n";
		copy_headers<IMAGE_NT_HEADERS32>(hdr, buf, buf_size, IMAGE_FILE_MACHINE_I386);
	}
	else {
		std::cout << "[*] 64bit module\n";
		copy_headers<IMAGE_NT_HEADERS64>(hdr, buf, buf_size, IMAGE_FILE_MACHINE_AMD64);
	}

	std::cout << "[*] Saving buffer!\n";
	dump_to_file(filename, buf, buf_size);
	return true;
}
